// Copyright 2019-present Facebook
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by entc, DO NOT EDIT.

package http

import (
	"net/http"
	"strings"

	"entgo.io/quynguyen-todo/ent"
	"github.com/gofiber/fiber/v2"
	"github.com/valyala/fasthttp/fasthttpadaptor"
	"go.uber.org/zap"
)

// handler has some convenience methods used on node-handlers.
type handler struct{}

// Bitmask to configure which routes to register.
type Routes uint32

func (rs Routes) has(r Routes) bool { return rs&r != 0 }

func FastHttpHandler(h http.HandlerFunc) fiber.Handler {
	return func(c *fiber.Ctx) error {
		ctx := c.Context()
		fasthttpH := fasthttpadaptor.NewFastHTTPHandlerFunc(h)
		fasthttpH(ctx)
		return nil
	}
}

const (
	CategoryCreate Routes = 1 << iota
	CategoryRead
	CategoryUpdate
	CategoryDelete
	CategoryList
	CategoryTodos
	CategoryRoutes = 1<<iota - 1
)

// CategoryHandler handles http crud operations on ent.Category.
type CategoryHandler struct {
	handler

	client *ent.Client
	log    *zap.Logger
}

func NewCategoryHandler(c *ent.Client, l *zap.Logger) *CategoryHandler {
	return &CategoryHandler{
		client: c,
		log:    l.With(zap.String("handler", "CategoryHandler")),
	}
}

// RegisterHandlers registers the generated handlers on the given chi router.
func (h *CategoryHandler) Mount(r fiber.Router, rs Routes) {
	if rs.has(CategoryCreate) {
		r.Post("/", FastHttpHandler(h.Create))
	}
	if rs.has(CategoryRead) {
		r.Get("/{id}", FastHttpHandler(h.Read))
	}
	if rs.has(CategoryUpdate) {
		r.Patch("/{id}", FastHttpHandler(h.Update))
	}
	if rs.has(CategoryDelete) {
		r.Delete("/{id}", FastHttpHandler(h.Delete))
	}
	if rs.has(CategoryList) {
		r.Get("/", FastHttpHandler(h.List))
	}
	if rs.has(CategoryTodos) {
		r.Get("/{id}/todos", FastHttpHandler(h.Todos))
	}
}

const (
	ProductCreate Routes = 1 << iota
	ProductRead
	ProductUpdate
	ProductDelete
	ProductList
	ProductRoutes = 1<<iota - 1
)

// ProductHandler handles http crud operations on ent.Product.
type ProductHandler struct {
	handler

	client *ent.Client
	log    *zap.Logger
}

func NewProductHandler(c *ent.Client, l *zap.Logger) *ProductHandler {
	return &ProductHandler{
		client: c,
		log:    l.With(zap.String("handler", "ProductHandler")),
	}
}

// RegisterHandlers registers the generated handlers on the given chi router.
func (h *ProductHandler) Mount(r fiber.Router, rs Routes) {
	if rs.has(ProductCreate) {
		r.Post("/", FastHttpHandler(h.Create))
	}
	if rs.has(ProductRead) {
		r.Get("/{id}", FastHttpHandler(h.Read))
	}
	if rs.has(ProductUpdate) {
		r.Patch("/{id}", FastHttpHandler(h.Update))
	}
	if rs.has(ProductDelete) {
		r.Delete("/{id}", FastHttpHandler(h.Delete))
	}
	if rs.has(ProductList) {
		r.Get("/", FastHttpHandler(h.List))
	}
}

const (
	TodoCreate Routes = 1 << iota
	TodoRead
	TodoUpdate
	TodoDelete
	TodoList
	TodoParent
	TodoChildren
	TodoCategory
	TodoSecret
	TodoRoutes = 1<<iota - 1
)

// TodoHandler handles http crud operations on ent.Todo.
type TodoHandler struct {
	handler

	client *ent.Client
	log    *zap.Logger
}

func NewTodoHandler(c *ent.Client, l *zap.Logger) *TodoHandler {
	return &TodoHandler{
		client: c,
		log:    l.With(zap.String("handler", "TodoHandler")),
	}
}

// RegisterHandlers registers the generated handlers on the given chi router.
func (h *TodoHandler) Mount(r fiber.Router, rs Routes) {
	if rs.has(TodoCreate) {
		r.Post("/", FastHttpHandler(h.Create))
	}
	if rs.has(TodoRead) {
		r.Get("/{id}", FastHttpHandler(h.Read))
	}
	if rs.has(TodoUpdate) {
		r.Patch("/{id}", FastHttpHandler(h.Update))
	}
	if rs.has(TodoDelete) {
		r.Delete("/{id}", FastHttpHandler(h.Delete))
	}
	if rs.has(TodoList) {
		r.Get("/", FastHttpHandler(h.List))
	}
	if rs.has(TodoParent) {
		r.Get("/{id}/parent", FastHttpHandler(h.Parent))
	}
	if rs.has(TodoChildren) {
		r.Get("/{id}/children", FastHttpHandler(h.Children))
	}
	if rs.has(TodoCategory) {
		r.Get("/{id}/category", FastHttpHandler(h.Category))
	}
	if rs.has(TodoSecret) {
		r.Get("/{id}/secret", FastHttpHandler(h.Secret))
	}
}

const (
	VerySecretCreate Routes = 1 << iota
	VerySecretRead
	VerySecretUpdate
	VerySecretDelete
	VerySecretList
	VerySecretRoutes = 1<<iota - 1
)

// VerySecretHandler handles http crud operations on ent.VerySecret.
type VerySecretHandler struct {
	handler

	client *ent.Client
	log    *zap.Logger
}

func NewVerySecretHandler(c *ent.Client, l *zap.Logger) *VerySecretHandler {
	return &VerySecretHandler{
		client: c,
		log:    l.With(zap.String("handler", "VerySecretHandler")),
	}
}

// RegisterHandlers registers the generated handlers on the given chi router.
func (h *VerySecretHandler) Mount(r fiber.Router, rs Routes) {
	if rs.has(VerySecretCreate) {
		r.Post("/", FastHttpHandler(h.Create))
	}
	if rs.has(VerySecretRead) {
		r.Get("/{id}", FastHttpHandler(h.Read))
	}
	if rs.has(VerySecretUpdate) {
		r.Patch("/{id}", FastHttpHandler(h.Update))
	}
	if rs.has(VerySecretDelete) {
		r.Delete("/{id}", FastHttpHandler(h.Delete))
	}
	if rs.has(VerySecretList) {
		r.Get("/", FastHttpHandler(h.List))
	}
}

func stripEntError(err error) string {
	return strings.TrimPrefix(err.Error(), "ent: ")
}

func zapFields(errs map[string]string) []zap.Field {
	if errs == nil || len(errs) == 0 {
		return nil
	}
	r := make([]zap.Field, 0)
	for k, v := range errs {
		r = append(r, zap.String(k, v))
	}
	return r
}
